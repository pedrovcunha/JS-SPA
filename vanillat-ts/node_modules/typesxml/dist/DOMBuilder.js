"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DOMBuilder = void 0;
const CData_1 = require("./CData");
const ProcessingInstruction_1 = require("./ProcessingInstruction");
const TextNode_1 = require("./TextNode");
const XMLComment_1 = require("./XMLComment");
const XMLDeclaration_1 = require("./XMLDeclaration");
const XMLDocument_1 = require("./XMLDocument");
const XMLDocumentType_1 = require("./XMLDocumentType");
const XMLElement_1 = require("./XMLElement");
const XMLUtils_1 = require("./XMLUtils");
class DOMBuilder {
    inCdData;
    currentCData;
    document;
    stack;
    catalog;
    dtdParser;
    grammarUrl;
    grammar;
    initialize() {
        this.document = new XMLDocument_1.XMLDocument();
        this.stack = new Array();
        this.inCdData = false;
    }
    setCatalog(catalog) {
        this.catalog = catalog;
    }
    setDTDParser(dtdParser) {
        this.dtdParser = dtdParser;
    }
    getDocument() {
        return this.document;
    }
    startDocument() {
        // do nothing
    }
    endDocument() {
        // do nothing
    }
    xmlDeclaration(version, encoding, standalone) {
        let xmlDclaration = new XMLDeclaration_1.XMLDeclaration(version, encoding, standalone);
        this.document.setXmlDeclaration(xmlDclaration);
    }
    startElement(name, atts) {
        let element = new XMLElement_1.XMLElement(name);
        atts.forEach((att) => {
            element.setAttribute(att);
        });
        if (this.stack.length > 0) {
            this.stack[this.stack.length - 1].addElement(element);
        }
        else {
            this.document.setRoot(element);
        }
        this.stack.push(element);
    }
    endElement(name) {
        this.stack.pop();
    }
    internalSubset(declaration) {
        let docType = this.document.getDocumentType();
        if (docType) {
            docType.setInternalSubset(declaration);
        }
    }
    characters(ch) {
        if (this.inCdData) {
            this.currentCData.setValue(this.currentCData.getValue() + ch);
            return;
        }
        let textNode = new TextNode_1.TextNode(ch);
        if (this.stack.length > 0) {
            this.stack[this.stack.length - 1].addTextNode(textNode);
        }
        else {
            this.document.addTextNode(textNode);
        }
    }
    ignorableWhitespace(ch) {
        let textNode = new TextNode_1.TextNode(ch);
        if (this.stack.length > 0) {
            this.stack[this.stack.length - 1].addTextNode(textNode);
        }
        else {
            this.document.addTextNode(textNode);
        }
    }
    comment(ch) {
        let comment = new XMLComment_1.XMLComment(ch);
        if (this.stack.length > 0) {
            this.stack[this.stack.length - 1].addComment(comment);
        }
        else {
            this.document.addComment(comment);
        }
    }
    processingInstruction(target, data) {
        let pi = new ProcessingInstruction_1.ProcessingInstruction(target, data);
        if (this.stack.length > 0) {
            this.stack[this.stack.length - 1].addProcessingInstruction(pi);
        }
        else {
            this.document.addProcessingInstruction(pi);
        }
        if (target === 'xml-model' && this.catalog) {
            let atts = this.parseXmlModel(data);
            let href = atts.get('href');
            let schematypens = atts.get('schematypens');
        }
    }
    parseXmlModel(text) {
        let map = new Map();
        let pairs = [];
        let separator = '';
        while (text.indexOf('=') != -1) {
            let i = 0;
            for (; i < text.length; i++) {
                let char = text[i];
                if (XMLUtils_1.XMLUtils.isXmlSpace(char) || '=' === char) {
                    break;
                }
            }
            for (; i < text.length; i++) {
                let char = text[i];
                if (separator === '' && ('\'' === char || '"' === char)) {
                    separator = char;
                    continue;
                }
                if (char === separator) {
                    break;
                }
            }
            // end of value
            let pair = text.substring(0, i + 1).trim();
            pairs.push(pair);
            text = text.substring(pair.length).trim();
            separator = '';
        }
        pairs.forEach((pair) => {
            let index = pair.indexOf('=');
            if (index === -1) {
                throw new Error('Malformed attributes list');
            }
            let name = pair.substring(0, index).trim();
            let value = pair.substring(index + 2, pair.length - 1);
            map.set(name, value);
        });
        return map;
    }
    startCDATA() {
        this.currentCData = new CData_1.CData('');
        this.inCdData = true;
    }
    endCDATA() {
        if (this.stack.length > 0) {
            this.stack[this.stack.length - 1].addCData(this.currentCData);
        }
        else {
            throw new Error("CData section outside of root element");
        }
        this.inCdData = false;
    }
    startDTD(name, publicId, systemId) {
        let docType = new XMLDocumentType_1.XMLDocumentType(name, publicId, systemId);
        this.document.setDocumentType(docType);
        if (this.catalog) {
            this.grammarUrl = this.catalog.resolveEntity(publicId, systemId);
            // TODO check grammar type (DTD, XDS or RelaxNG) and use the ritght parser
            if (this.dtdParser && this.grammarUrl) {
                let dtdGrammar = this.dtdParser.parseDTD(this.grammarUrl);
                if (dtdGrammar) {
                    this.grammar = dtdGrammar;
                }
            }
        }
    }
    endDTD() {
        // do nothing
    }
    skippedEntity(name) {
        // TODO
        throw new Error("Method not implemented.");
    }
}
exports.DOMBuilder = DOMBuilder;
//# sourceMappingURL=DOMBuilder.js.map