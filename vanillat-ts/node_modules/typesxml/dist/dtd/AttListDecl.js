"use strict";
/*******************************************************************************
 * Copyright (c) 2023 - 2024 Maxprograms.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse   License 1.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-v10.html
 *
 * Contributors:
 *     Maxprograms - initial API and implementation
 *******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttListDecl = void 0;
const Constants_1 = require("../Constants");
const AttDecl_1 = require("./AttDecl");
class AttListDecl {
    name;
    attributes;
    static attTypes = ['CDATA', 'ID', 'IDREF', 'IDREFS', 'ENTITY', 'ENTITIES', 'NMTOKEN', 'NMTOKENS'];
    constructor(name, attributesText) {
        this.name = name;
        this.attributes = new Map();
        this.parseAttributes(attributesText);
    }
    getName() {
        return this.name;
    }
    getAttributes() {
        return this.attributes;
    }
    parseAttributes(text) {
        let parts = this.split(text);
        let index = 0;
        while (index < parts.length) {
            let name = parts[index++];
            let attType = parts[index++];
            let defaultDecl = '';
            let defaultValue = '';
            if (AttListDecl.attTypes.includes(attType)) {
                defaultDecl = parts[index++];
                if (defaultDecl === '#FIXED') {
                    defaultValue = parts[index++];
                }
            }
            else {
                if (attType === 'NOTATION') {
                    // TODO parse the notations in the ennumeration that follows
                }
                else {
                    defaultValue = parts[index++];
                }
            }
            let att = new AttDecl_1.AttDecl(name, attType, defaultDecl, defaultValue);
            this.attributes.set(name, att);
        }
    }
    split(text) {
        let result = [];
        let word = '';
        for (let i = 0; i < text.length; i++) {
            let c = text.charAt(i);
            if (c === '(') {
                // starts an enumeration
                let enumeration = '(';
                while (c !== ')') {
                    c = text.charAt(++i);
                    enumeration += c;
                }
                result.push(enumeration);
                continue;
            }
            if (c === ' ' || c === '\n' || c === '\r' || c === '\t') {
                if (word.length > 0) {
                    result.push(word);
                    word = '';
                }
            }
            else {
                word += c;
            }
        }
        if (word.length > 0) {
            result.push(word);
        }
        return result;
    }
    getNodeType() {
        return Constants_1.Constants.ATTRIBUTE_LIST_DECL_NODE;
    }
    toString() {
        let result = '<!ATTLIST ' + this.name + '\n';
        this.attributes.forEach((a) => {
            result += ' ' + a.toString() + '\n';
        });
        return result + '>';
    }
    equals(node) {
        if (node instanceof AttListDecl) {
            let nodeAtts = node.getAttributes();
            if (this.name !== node.getName() || this.attributes.size !== nodeAtts.size) {
                return false;
            }
            this.attributes.forEach((value, key) => {
                if (!value.equals(nodeAtts.get(key))) {
                    return false;
                }
            });
            return true;
        }
        return false;
    }
}
exports.AttListDecl = AttListDecl;
//# sourceMappingURL=AttListDecl.js.map