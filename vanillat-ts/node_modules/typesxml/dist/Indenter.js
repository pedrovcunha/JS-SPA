"use strict";
/*******************************************************************************
 * Copyright (c) 2023 - 2024 Maxprograms.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse   License 1.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-v10.html
 *
 * Contributors:
 *     Maxprograms - initial API and implementation
 *******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Indenter = void 0;
const Constants_1 = require("./Constants");
const TextNode_1 = require("./TextNode");
const XMLUtils_1 = require("./XMLUtils");
class Indenter {
    numSpaces;
    indentLevel;
    constructor(spaces, level) {
        this.numSpaces = spaces;
        if (level !== undefined) {
            this.indentLevel = level;
        }
        else {
            this.indentLevel = 1;
        }
    }
    setSpaces(spaces) {
        this.numSpaces = spaces;
    }
    setLevel(level) {
        this.indentLevel = level;
    }
    indent(e) {
        if (e.hasAttribute('xml:space') && 'preserve' === e.getAttribute('xml:space').getValue()) {
            return;
        }
        if (!this.hasText(e)) {
            this.indentElement(e);
        }
        this.indentLevel++;
        let children = e.getChildren();
        children.forEach((child) => {
            this.indent(child);
        });
        this.indentLevel--;
    }
    indentElement(e) {
        let start = '\n';
        let end = '\n';
        for (let i = 0; i < (this.indentLevel * this.numSpaces); i++) {
            start += ' ';
        }
        for (let i = 0; i < ((this.indentLevel - 1) * this.numSpaces); i++) {
            end += ' ';
        }
        let content = new Array();
        let nodes = e.getContent();
        nodes.forEach((node) => {
            if (!(node instanceof TextNode_1.TextNode)) {
                content.push(new TextNode_1.TextNode(start));
                content.push(node);
            }
        });
        if (content.length !== 0) {
            content.push(new TextNode_1.TextNode(end));
        }
        e.setContent(content);
    }
    hasText(e) {
        let result = false;
        let content = e.getContent();
        content.forEach((node) => {
            if (node.getNodeType() === Constants_1.Constants.TEXT_NODE) {
                let text = node.getValue();
                let length = text.length;
                for (let i = 0; i < length; i++) {
                    if (!XMLUtils_1.XMLUtils.isXmlSpace(text.charAt(i))) {
                        result = true;
                        break;
                    }
                }
            }
        });
        return result;
    }
}
exports.Indenter = Indenter;
//# sourceMappingURL=Indenter.js.map