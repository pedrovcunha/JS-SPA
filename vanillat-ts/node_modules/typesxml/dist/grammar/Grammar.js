"use strict";
/*******************************************************************************
 * Copyright (c) 2023 - 2024 Maxprograms.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse   License 1.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-v10.html
 *
 * Contributors:
 *     Maxprograms - initial API and implementation
 *******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Grammar = void 0;
const XMLUtils_1 = require("../XMLUtils");
const EntityDecl_1 = require("../dtd/EntityDecl");
const ContentModel_1 = require("./ContentModel");
class Grammar {
    models;
    entitiesMap;
    attributesMap;
    elementDeclMap;
    notationsMap;
    constructor() {
        this.models = new Map();
        this.elementDeclMap = new Map();
        this.attributesMap = new Map();
        this.entitiesMap = new Map();
        this.notationsMap = new Map();
        this.addPredefinedEntities();
    }
    addPredefinedEntities() {
        this.addEntity(new EntityDecl_1.EntityDecl('lt', false, '<', '', '', ''));
        this.addEntity(new EntityDecl_1.EntityDecl('gt', false, '>', '', '', ''));
        this.addEntity(new EntityDecl_1.EntityDecl('amp', false, '&', '', '', ''));
        this.addEntity(new EntityDecl_1.EntityDecl('apos', false, "'", '', '', ''));
        this.addEntity(new EntityDecl_1.EntityDecl('quot', false, '"', '', '', ''));
    }
    getContentModel(elementName) {
        return this.models.get(elementName);
    }
    toString() {
        let result;
        this.models.forEach((value) => {
            result = result + value.toString() + '\n';
        });
        return result;
    }
    addElement(elementDecl) {
        if (!this.elementDeclMap.has(elementDecl.getName())) {
            this.elementDeclMap.set(elementDecl.getName(), elementDecl);
        }
    }
    addAttributes(element, attributes) {
        this.attributesMap.set(element, attributes);
    }
    resolveParameterEntities(text) {
        while (XMLUtils_1.XMLUtils.hasParameterEntity(text)) {
            let start = text.indexOf('%');
            let end = text.indexOf(';');
            let entityName = text.substring(start + '%'.length, end);
            let entity = this.getEntity(entityName);
            if (entity === undefined) {
                throw new Error('Unknown entity: ' + entityName);
            }
            text = text.replace('%' + entityName + ';', entity.getValue());
        }
        return text;
    }
    addEntity(entityDecl) {
        if (!this.entitiesMap.has(entityDecl.getName())) {
            this.entitiesMap.set(entityDecl.getName(), entityDecl);
        }
    }
    getEntity(entityName) {
        return this.entitiesMap.get(entityName);
    }
    addNotation(notation) {
        if (!this.notationsMap.has(notation.getName())) {
            this.notationsMap.set(notation.getName(), notation);
        }
    }
    merge(grammar) {
        grammar.getEntitiesMap().forEach((value, key) => {
            if (!this.entitiesMap.has(key)) {
                this.entitiesMap.set(key, value);
            }
        });
        grammar.getAttributesMap().forEach((value, key) => {
            if (!this.attributesMap.has(key)) {
                this.attributesMap.set(key, value);
            }
        });
        grammar.getElementDeclMap().forEach((value, key) => {
            if (!this.elementDeclMap.has(key)) {
                this.elementDeclMap.set(key, value);
            }
        });
        grammar.getNotationsMap().forEach((value, key) => {
            if (!this.notationsMap.has(key)) {
                this.notationsMap.set(key, value);
            }
        });
    }
    getNotationsMap() {
        return this.notationsMap;
    }
    getElementDeclMap() {
        return this.elementDeclMap;
    }
    getEntitiesMap() {
        return this.entitiesMap;
    }
    processModels() {
        this.elementDeclMap.forEach((elementDecl) => {
            let name = elementDecl.getName();
            if (XMLUtils_1.XMLUtils.hasParameterEntity(name)) {
                name = this.resolveParameterEntities(name);
            }
            let contentSpec = elementDecl.getContentSpec();
            if (XMLUtils_1.XMLUtils.hasParameterEntity(contentSpec)) {
                contentSpec = this.resolveParameterEntities(contentSpec);
            }
            let model = new ContentModel_1.ContentModel(this, name, contentSpec);
            this.models.set(name, model);
        });
    }
    getAttributesMap() {
        return this.attributesMap;
    }
    getElementAttributesMap(element) {
        return this.attributesMap.get(element);
    }
}
exports.Grammar = Grammar;
//# sourceMappingURL=Grammar.js.map